## TCP 连接三次握手

### 三次握手的过程
- 1. **第一次握手**: 客户端发送 `SYN`（同步序列编号）报文，请求建立连接，进入 `SYN_SENT` 状态。

- 2. **第二次握手**: 服务器收到 `SYN` 后，若同意连接，回复 `SYN-ACK`（同步确认）报文，进入 `SYN_RCVD` 状态。

- 3. **第三次握手**: 客户端收到 `SYN-ACK` 后，发送 `ACK`（确认）报文，双方进入 `ESTABLISHED` 状态，连接建立完成。

### 为什么需要三次握手？
- **确认双向通信能力**  
  - 第一次握手：验证客户端→服务器的通道可用。  
  - 第二次握手：验证服务器→客户端的通道可用。  
  - 第三次握手：确认客户端已收到服务器的响应。  
- **避免历史连接问题**  
  两次握手可能导致服务器因延迟的旧请求建立无效连接，浪费资源。  
- **四次握手的冗余性**  
  三次已足够确保可靠性，四次会增加额外开销。

---

## TCP 连接四次挥手

### 四次挥手的过程
1. **第一次挥手**  
   客户端发送 `FIN` 报文（序列号 `seq=x`），进入 `FIN-WAIT-1` 状态，表示停止发送数据。

2. **第二次挥手**  
   服务端回复 `ACK` 报文（`seq=x+1`），进入 `CLOSE-WAIT` 状态，客户端进入 `FIN-WAIT-2` 状态。

3. **第三次挥手**  
   服务端发送 `FIN` 报文（`seq=y+1`），进入 `LAST-ACK` 状态，表示服务端停止发送数据。

4. **第四次挥手**  
   客户端回复 `ACK` 报文（`seq=y+2`），进入 `TIME-WAIT` 状态；服务端收到后关闭连接。  
   （客户端等待 `2MSL` 后关闭，确保服务端收到确认）

### 为什么需要四次挥手？
- **全双工通信特性**  
  TCP 允许双向独立关闭：  
  - 两次挥手释放单向连接（如客户端→服务端）。  
  - 另外两次释放反向连接（服务端→客户端）。  
- **确保数据完整性**  
  四次挥手保证双方均确认对方无遗留数据需传输。  
- **避免数据丢失**  
  `TIME-WAIT` 状态允许重传未到达的 `ACK`，防止被动关闭方重复发送 `FIN`。

---

## HTTP Keep-Alive vs TCP Keep-Alive

### HTTP Keep-Alive（应用层）
- **功能**：实现 HTTP 长连接，复用同一 TCP 连接处理多个请求/响应。  
- **优点**：减少重复建立/关闭连接的开销，提升性能。  
- **实现方式**：通过 HTTP 头设置 `Connection: keep-alive`。  
- **生命周期**：由应用层控制，可自定义超时时间或最大请求数。

### TCP Keep-Alive（传输层）
- **功能**：检测空闲连接是否有效，防止因网络故障导致“半开连接”。  
- **机制**：若连接空闲超时，发送探测包确认对方是否存活。  
- **参数**：  
  - `tcp_keepalive_time`：默认空闲检测时间（如 7200 秒）。  
  - `tcp_keepalive_intvl`：探测包重试间隔（如 75 秒）。  
  - `tcp_keepalive_probes`：最大重试次数（如 9 次）。  

### 两者区别
| **特性**       | **HTTP Keep-Alive**                | **TCP Keep-Alive**               |
|----------------|------------------------------------|-----------------------------------|
| 层级           | 应用层                             | 传输层                           |
| 目的           | 复用 TCP 连接减少开销              | 检测空闲连接是否存活              |
| 控制方式       | 通过 HTTP 头显式设置               | 内核参数，默认关闭需手动配置       |
| 生命周期       | 由 HTTP 事务决定                   | 由内核参数和网络状态决定           |

---

**总结**  
三次握手确保可靠的双向通信，四次挥手保障连接安全关闭，而 Keep-Alive 机制分别在应用层和传输层优化了连接的复用与健壮性。
