## 一. 线程同步方式

### 互斥锁（`Mutex`）
- **核心机制**：通过原子操作实现临界区保护
- **工作模式**：
  - `lock()`阻塞式获取锁
  - `try_lock()`非阻塞尝试获取
  - `unlock()`显式释放锁
- **典型应用**：共享数据结构保护

### 条件变量（`Condition Variable`）
- **协同机制**：
  - `wait()`：释放锁并进入等待队列
  - `notify_one()`：唤醒单个等待线程
  - `notify_all()`：广播唤醒所有线程
- **经典模式**：生产者-消费者模型

### 读写锁（`Read-Write Lock`）
- **访问策略**：
  - 共享读锁：允许多个并发读操作
  - 独占写锁：保证写操作原子性
- **实现变种**：
  - 读优先锁
  - 写优先锁
  - 公平锁

### 信号量（`Semaphore`）
- **核心参数**：计数器（可用资源数）
- **操作原语**：
  - `P`操作（`proberen`）：资源申请
  - `V`操作（`verhogen`）：资源释放
- **演进形式**：二进制信号量（互斥锁特例）

---

## 二. 页面置换算法

### 最佳置换算法（`OPT`）
- **理论基准**：选择未来最长时间不使用的页面
- **实现限制**：需要预知未来访问序列
- **应用价值**：算法性能评估的黄金标准

### 先进先出（`FIFO`）
- **实现结构**：队列管理页面进入顺序
- **Belady异常**：增加内存页框可能反而增加缺页率
- **改进方案**：`Second Chance`算法

### 最近最久未使用（`LRU`）
- **硬件支持**：
  - 访问时间戳寄存器
  - 矩阵法近似实现
- **实现挑战**：维护精确访问顺序的高开销

### 时钟算法（`CLOCK`）
- **环形结构**：将内存页组织为循环链表
- **访问位机制**：
  | 指针状态 | 访问位 | 处理动作               |
  |----------|--------|------------------------|
  | 初始扫描 | 0      | 直接置换               |
  |          | 1      | 置0后跳过              |
  | 二次扫描 | 0      | 置换                   |
- **优化版本**：改进型`Clock`算法（考虑修改位）

### 最不经常使用（`LFU`）
- **计数机制**：维护页面访问频率计数器
- **老化策略**：定期衰减历史计数
- **存储开销**：需要额外空间维护频率数据
